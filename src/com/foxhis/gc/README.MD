深入java虚拟机
1内存管理机制
1.1内存模型：方法区，虚拟机栈，本地方法栈，堆，程序计数器

程序计数器：小内存，放当前线程的执行的字节码的行号指示器，程序的跳转，异常，下一行的指令运行都是依赖程序计数器
虚拟机栈：线程私有，生命周期与线程一致，简称局部变量表，编译的时候完成分配，分配是固定的
本地方法栈：为虚拟机使用到的Native方法服务，即调用Native方法
堆：存放对象，被所有线程共享，虚拟机启动时候根据参数-Xms,-Xmx创建 。如 new Object()
方法区：存储已被虚拟机加载的的类信息Class（如类名字，访问修饰符，字段描述，方法描述），常量，静态变量，即时编译的代码。如final String s="a"
常量池：是方法区里的一部分，存放编译期间生成的各种字面量，和符合引用如，数字123，符合“”

1.2.直接内存：是虚拟机外的内存，NIO用到，JNA申请内存用到

1.3.对象访问：两种方式，1.句柄指针访问，2.直接指针访问

1.4.OutOfMemoryError:参考例子

2.垃圾收集器与内存分配策略
2.1 引用计数法：给对象中添加一个引用计数器，每当对象被引用则加1，当引用失效则减1，为0则不用，可回收
     优点：效率高，缺点：很难解决对象之间互相引用
2.2 根搜索算法：通过名为“GC Roots”对象为起点，根据这个节点向下搜索，所走路径叫引用链，当对象没有任何引用链则不可达，可回收。
   名为“GC Roots”对象：虚拟机栈中引用对象，方法区类静态属性引用对象和常量引用对象，本地方法栈JNI引用对象
   引用定义：如果reference类型中数据有值代表另一块内存的起始地址，则这块内存代表着一个引用。
 java丰富引用：强引用，软引用，弱引用，虚引用

2.3 垃圾收集算法
2.3.1 标记-清除法：先标记不可用对象，再清除不可用对象，缺点：效率低，内存空间碎片多
            复制-清除法：先将可用内存一分为二AB，将A作为内存分配，B作为回收存储，将A中可用的对象复制到B，然后将A清除。缺点：成本高
            标记-整理法：先标记可用对象，然后移动到一端，然后将端边界的内存清理
            分代-收集法：（当前商用）根据对象存活周期将内存划分几个块，一般堆分为新生代和老年代，再根据年代的特点，将新生代采用复制-清除法，因为新生代对象每次收集的时候会有大部分内存死去，而老年代对象存活比较长久，则采用标记整理或者标记清除法
2.4 垃圾收集器
    Serial收集器：单线程收集新生代，停止一切用户工作线程。优点：高效（针对client客户桌面程序）停顿时间几十到几百毫秒
    ParNew收集器：多线程收集器与Serial收集算法基本一致。优点：Server端首选新生代收集器，可配合CMS收集器工作。缺点，单CPU下效率不如Serial。默认收集线程数量与CPU个数相同，也可以用-XX：ParallelGCThreads参数来控制线程数量。
    Parallel Scavenge收集器：多线程，复制算法，新生代。与CMS收集器对比，CMS更多是为缩短用户线程停顿时间，而该处理器是控制达到一定吞吐量（运行用户时间/运行代码+垃圾收集时间，如虚拟机总运行100分钟，垃圾回收1分钟，那吞吐=99%），适用于后台运算，交互不多的任务。
    Serial Old收集器:单线程，老年代，标记整理法。
    Parallel Old收集器：多线程，老年代，标记整理法。常与Parallel Scavenge收集器一起。
    CMS收集器：适用B/S场景服务端，缩短用户线程暂停时间。标记-清除法，老年代，4个过程，初始标记，并发标记，重新标记，并发清除，最耗时的是并发标记和并发清除
    G1收集器：1.7后发布，标记整理法，准确控制停顿，将整个新，老一起划分区域，优先回收垃圾最多地方。
2.5 内存分配与回收策略


visualvm插件地址：https://visualvm.github.io/uc/release14/updates.html(注意，jdk版本不一样，对应插件也不一样)

    




